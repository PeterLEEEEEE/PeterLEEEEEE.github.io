I"p8<hr />
<h3 id="그래프graph">그래프(graph)</h3>

<ul>
  <li>트리가 1:n 구조의 자료구조 였다면 그래프는 n:n 구조의 자료구조이다.</li>
  <li>
    <p>그래프의 G는 (V, E)로 표시하는데, 이는 객체를 나타내는 <strong>정점(vertex)</strong>과 객체를 연결하는 <strong>간선(edge)</strong>으로 구성되어 있다.</p>
  </li>
  <li>정점(vertex): – 노드라고도 불림
    <ul>
      <li>여러 가지 특성을 가질 수 있는 객체를 의미</li>
      <li>V(G): 그래프 G의 정점들의 집합</li>
    </ul>
  </li>
  <li>간선(edge): – 링크
    <ul>
      <li>정점들 간의 관계 의미</li>
      <li>E(G): 그래프 G의 간선들의 집합
<img src="https://user-images.githubusercontent.com/52132160/88883052-44c1ab80-d26e-11ea-9760-43423be7f747.png" alt="image" /></li>
    </ul>
  </li>
</ul>

<h5 id="그래프의-종류">그래프의 종류</h5>

<ol>
  <li>무방향 그래프(undirected graph)
    <ul>
      <li>두 정점을 연결하는 간선에 방향이 없는 그래프</li>
      <li>정점 Vi와 Vj를 연결하는 간선을 (Vi, Vj)라고 나타낸다.
 <strong>(Vi, Vj) = (Vj, Vi)</strong>
<img src="https://user-images.githubusercontent.com/52132160/88881887-8f8df400-d26b-11ea-8153-bab577d4511f.png" alt="image" />
<img src="https://user-images.githubusercontent.com/52132160/88881911-a0d70080-d26b-11ea-8272-5f87d13aebc8.png" alt="image" /></li>
    </ul>
  </li>
  <li>방향 그래프(directed graph), digraph
    <ul>
      <li>간선에 방향이 있는 그래프</li>
      <li>정점 Vi에서 Vj를 연결하는 간선 즉, Vi -&gt; Vj를 &lt;Vi, Vj&gt; 로 표현
        <ul>
          <li>Vi를 tail, Vj를 head 라고 한다.</li>
          <li><strong>&lt;Vi, Vj&gt;와 &lt;Vj, Vi&gt;</strong>는 서로 다른 간선이다.   <br />
<img src="https://user-images.githubusercontent.com/52132160/88882128-3a061700-d26c-11ea-94ff-c1ed69827eec.png" alt="image" /></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>가중치 그래프(weighted graph), 네트워크
    <ul>
      <li>간선에 비용(cost)이나 가중치(weight)가 할당된 그래프
<img src="https://user-images.githubusercontent.com/52132160/88882569-3aeb7880-d26d-11ea-9589-49e5e5a66585.png" alt="image" /></li>
    </ul>
  </li>
</ol>

<ul>
  <li>etc. 완전 그래프(complete graph), 부분 그래프(subgraph)등 이 존재한다.</li>
</ul>

<hr />
<hr />
<h4 id="그래프의-구현">그래프의 구현</h4>
<ul>
  <li>무방향, 방향 그래프 모두 <strong>인접 행렬</strong>과 <strong>인접 리스트</strong> 두 가지 방법을 통해 구현 가능하다.</li>
  <li>나는 화살표로 고통받는 걸 좋아하기 때문에 인접 리스트로 구현해 보았다.</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/52132160/88883876-5015d680-d270-11ea-9b6c-286ab90e1ac7.png" alt="image" /><a name="footnote_1"></a>:무방향 그래프 인접리스트 표현
<img src="https://user-images.githubusercontent.com/52132160/88884514-bf3ffa80-d271-11ea-85b7-d21596143572.png" alt="image" />
<a name="footnote_1"></a>:방향 그래프 인접리스트 표현</p>

<h4 id="무방향-그래프c">무방향 그래프.c</h4>
<p>{% highlight cpp %}
#include <stdio.h>
#include <stdlib.h>
#define MAX_VERTEX 30                   // 헤드 포인터 배열의 최대 크기</stdlib.h></stdio.h></p>

<p>// 인접 리스트의 노드 구조를 구조체로 정의
typedef struct graphNode {
    int vertex;                         // 정점을 나타내는 데이터 필드
    struct graphNode* link;             // 다음 인접 정점을 연결하는 링크 필드
} graphNode;</p>

<p>// 그래프를 인접 리스트로 표현하기 위한 구조체 정의
typedef struct graphType {
    int n;                              // 그래프의 정점 개수
    graphNode* adjList_H[MAX_VERTEX];   // 그래프 정점에 대한 헤드 포인터 배열
} graphType;</p>

<p>// 공백 그래프를 생성하는 연산
void createGraph(graphType* g) {
    int v;
    g-&gt;n = 0;                           // 그래프의 정점 개수를 0으로 초기화
    for (v = 0; v&lt;MAX_VERTEX; v++)
        g-&gt;adjList_H[v] = NULL;         // 그래프의 정점에 대한 헤드 포인터 배열을 NULL로 초기화
}</p>

<p>// 그래프 g에 정점 v를 삽입하는 연산
void insertVertex(graphType* g, int v) {
    if (((g-&gt;n) + 1)&gt;MAX_VERTEX) {
        printf(“\n 그래프 정점의 개수를 초과하였습니다!”);
        return;
    }
    g-&gt;n++;                             // 그래프의 정점 개수 n을 하나 증가
}</p>

<p>// 그래프 g에 간선 (u, v)를 삽입하는 연산
void insertEdge(graphType* g, int u, int v) {
    graphNode* node;</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>// 간선 (u, v)를 삽입하기 위해 정점 u와 정점 v가 현재 그래프에 있는지 확인
if (u &gt;= g-&gt;n || v &gt;= g-&gt;n) {
    printf("\n 그래프에 없는 정점입니다!");
    return;
}
node = (graphNode *)malloc(sizeof(graphNode));
node-&gt;vertex = v;
node-&gt;link = g-&gt;adjList_H[u];   // 삽입 간선에 대한 노드를 리스트의 첫 번째 노드로 연결
g-&gt;adjList_H[u] = node; }
</code></pre></div></div>

<p>// 그래프 g의 각 정점에 대한 인접 리스트를 출력하는 연산
void print_adjList(graphType* g) {
    int i;
    graphNode* p;
    for (i = 0; i<g->n; i++) {
        printf("\n\t\t정점 %c의 인접 리스트", i + 65);
        p = g-&gt;adjList_H[i];
        while (p) {
            printf(" -&gt; %c", p-&gt;vertex + 65); // 정점 0~3을 A~D로 출력
            p = p-&gt;link;
        }
    }
}</g-></p>

<p>void main() {
    int i;
    graphType *G1, *G2, *G3, *G4;
    G1 = (graphType *)malloc(sizeof(graphType));
    G2 = (graphType *)malloc(sizeof(graphType));
    G3 = (graphType *)malloc(sizeof(graphType));
    G4 = (graphType *)malloc(sizeof(graphType));
    createGraph(G1); createGraph(G2); createGraph(G3); createGraph(G4);</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>// 그래프 G1
for (i = 0; i<span class="nt">&lt;</span><span class="err">4;</span> <span class="na">i</span><span class="err">++)</span>
    <span class="na">insertVertex</span><span class="err">(</span><span class="na">G1</span><span class="err">,</span> <span class="na">i</span><span class="err">);</span>    <span class="err">//</span> <span class="na">G1의</span> <span class="na">정점</span> <span class="err">0~3</span> <span class="na">삽입</span>
<span class="na">insertEdge</span><span class="err">(</span><span class="na">G1</span><span class="err">,</span> <span class="err">0,</span> <span class="err">3);</span>
<span class="na">insertEdge</span><span class="err">(</span><span class="na">G1</span><span class="err">,</span> <span class="err">0,</span> <span class="err">1);</span>
<span class="na">insertEdge</span><span class="err">(</span><span class="na">G1</span><span class="err">,</span> <span class="err">1,</span> <span class="err">3);</span>
<span class="na">insertEdge</span><span class="err">(</span><span class="na">G1</span><span class="err">,</span> <span class="err">1,</span> <span class="err">2);</span>
<span class="na">insertEdge</span><span class="err">(</span><span class="na">G1</span><span class="err">,</span> <span class="err">1,</span> <span class="err">0);</span>
<span class="na">insertEdge</span><span class="err">(</span><span class="na">G1</span><span class="err">,</span> <span class="err">2,</span> <span class="err">3);</span>
<span class="na">insertEdge</span><span class="err">(</span><span class="na">G1</span><span class="err">,</span> <span class="err">2,</span> <span class="err">1);</span>
<span class="na">insertEdge</span><span class="err">(</span><span class="na">G1</span><span class="err">,</span> <span class="err">3,</span> <span class="err">2);</span>
<span class="na">insertEdge</span><span class="err">(</span><span class="na">G1</span><span class="err">,</span> <span class="err">3,</span> <span class="err">1);</span>
<span class="na">insertEdge</span><span class="err">(</span><span class="na">G1</span><span class="err">,</span> <span class="err">3,</span> <span class="err">0);</span>
<span class="na">printf</span><span class="err">("\</span><span class="na">n</span> <span class="na">G1의</span> <span class="na">인접</span> <span class="na">리스트</span><span class="err">");</span>
<span class="na">print_adjList</span><span class="err">(</span><span class="na">G1</span><span class="err">);</span>

<span class="err">/</span><span class="na">*</span>
<span class="err">//</span> <span class="na">그래프</span> <span class="na">G2</span>
<span class="na">for</span> <span class="na">(i = </span><span class="s">0;</span> <span class="na">i</span><span class="err">&lt;3;</span> <span class="na">i</span><span class="err">++)</span>
    <span class="na">insertVertex</span><span class="err">(</span><span class="na">G2</span><span class="err">,</span> <span class="na">i</span><span class="err">);</span>    <span class="err">//</span> <span class="na">G2의</span> <span class="na">정점</span> <span class="err">0~2</span> <span class="na">삽입</span>
<span class="na">insertEdge</span><span class="err">(</span><span class="na">G2</span><span class="err">,</span> <span class="err">0,</span> <span class="err">2);</span>
<span class="na">insertEdge</span><span class="err">(</span><span class="na">G2</span><span class="err">,</span> <span class="err">0,</span> <span class="err">1);</span>
<span class="na">insertEdge</span><span class="err">(</span><span class="na">G2</span><span class="err">,</span> <span class="err">1,</span> <span class="err">2);</span>
<span class="na">insertEdge</span><span class="err">(</span><span class="na">G2</span><span class="err">,</span> <span class="err">1,</span> <span class="err">0);</span>
<span class="na">insertEdge</span><span class="err">(</span><span class="na">G2</span><span class="err">,</span> <span class="err">2,</span> <span class="err">1);</span>
<span class="na">insertEdge</span><span class="err">(</span><span class="na">G2</span><span class="err">,</span> <span class="err">2,</span> <span class="err">0);</span>
<span class="na">printf</span><span class="err">("\</span><span class="na">n</span><span class="err">\</span><span class="na">n</span> <span class="na">G2의</span> <span class="na">인접</span> <span class="na">리스트</span><span class="err">");</span>
<span class="na">print_adjList</span><span class="err">(</span><span class="na">G2</span><span class="err">);</span>

<span class="err">//</span> <span class="na">그래프</span> <span class="na">G3</span>
<span class="na">for</span> <span class="na">(i = </span><span class="s">0;</span> <span class="na">i</span><span class="err">&lt;4;</span> <span class="na">i</span><span class="err">++)</span>
    <span class="na">insertVertex</span><span class="err">(</span><span class="na">G3</span><span class="err">,</span> <span class="na">i</span><span class="err">);</span>    <span class="err">//</span> <span class="na">G3의</span> <span class="na">정점</span> <span class="err">0~3</span> <span class="na">삽입</span>
<span class="na">insertEdge</span><span class="err">(</span><span class="na">G3</span><span class="err">,</span> <span class="err">0,</span> <span class="err">3);</span>
<span class="na">insertEdge</span><span class="err">(</span><span class="na">G3</span><span class="err">,</span> <span class="err">0,</span> <span class="err">1);</span>
<span class="na">insertEdge</span><span class="err">(</span><span class="na">G3</span><span class="err">,</span> <span class="err">1,</span> <span class="err">3);</span>
<span class="na">insertEdge</span><span class="err">(</span><span class="na">G3</span><span class="err">,</span> <span class="err">1,</span> <span class="err">2);</span>
<span class="na">insertEdge</span><span class="err">(</span><span class="na">G3</span><span class="err">,</span> <span class="err">2,</span> <span class="err">3);</span>
<span class="na">printf</span><span class="err">("\</span><span class="na">n</span><span class="err">\</span><span class="na">n</span> <span class="na">G3의</span> <span class="na">인접</span> <span class="na">리스트</span><span class="err">");</span>
<span class="na">print_adjList</span><span class="err">(</span><span class="na">G3</span><span class="err">);</span>

<span class="err">//</span> <span class="na">그래프</span> <span class="na">G4</span>
<span class="na">for</span> <span class="na">(i = </span><span class="s">0;</span> <span class="na">i</span><span class="err">&lt;3;</span> <span class="na">i</span><span class="err">++)</span>
    <span class="na">insertVertex</span><span class="err">(</span><span class="na">G4</span><span class="err">,</span> <span class="na">i</span><span class="err">);</span>    <span class="err">//</span> <span class="na">G4의</span> <span class="na">정점</span> <span class="err">0~2</span> <span class="na">삽입</span>
<span class="na">insertEdge</span><span class="err">(</span><span class="na">G4</span><span class="err">,</span> <span class="err">0,</span> <span class="err">2);</span>
<span class="na">insertEdge</span><span class="err">(</span><span class="na">G4</span><span class="err">,</span> <span class="err">0,</span> <span class="err">1);</span>
<span class="na">insertEdge</span><span class="err">(</span><span class="na">G4</span><span class="err">,</span> <span class="err">1,</span> <span class="err">2);</span>
<span class="na">insertEdge</span><span class="err">(</span><span class="na">G4</span><span class="err">,</span> <span class="err">1,</span> <span class="err">0);</span>
<span class="na">printf</span><span class="err">("\</span><span class="na">n</span><span class="err">\</span><span class="na">n</span> <span class="na">G4의</span> <span class="na">인접</span> <span class="na">리스트</span><span class="err">");</span>
<span class="na">print_adjList</span><span class="err">(</span><span class="na">G4</span><span class="err">);</span> <span class="na">*</span><span class="err">/</span>

<span class="na">getchar</span><span class="err">();</span> <span class="err">}</span>
</code></pre></div></div>

<p>{% endhighlight %}</p>

<hr />

:ET