I"Y<hr />

<h3 id="소프트웨어-아키텍처구조도">소프트웨어 아키텍처(구조도)</h3>

<p><strong>소프트웨어 아키텍처의 설계</strong></p>
<ul>
  <li>소프트웨어 개발 시 원칙과 지침이 됨, 소통 도구</li>
  <li>좋은 품질 유지(기능적, 비기능적)</li>
</ul>

<p>1). <strong>모듈화</strong></p>
<ul>
  <li>소프트웨어의 성능 향상, 시스템의 수정 및 재사용, 유지 관리가 용이하도록 기능들을 모듈 단위로 <code class="language-html highlighter-rouge">나누는</code> 것</li>
  <li>너무 작게 나누면 개수가 적어 통합 비용은 적게 들지만 모듈 하나의 개발 비용은 많이 들게 된다.
<br /><br />
2). <strong>추상화</strong></li>
  <li>불필요한 부분을 생략하고 필요한 부분을 강조하여 모델화
    <ul>
      <li><strong>과정추상화:</strong> 자세한 수행 과정을 정의하지 않고, 전반적인 흐름만 파악할 수 있게 설계하는 법</li>
      <li><strong>데이터 추상화:</strong> 데이터 구조를 대표할 수 있는 표현으로 대체하는 방법</li>
      <li><strong>제어 추상화:</strong> 이벤트 발생의 정환 절차나 방법을 정의하지 않고, 대표할 수 있는 표현으로 대체
<br /><br />  <br />
3). <strong>단계적 분해</strong></li>
    </ul>
  </li>
  <li>하향식 설계 방법: 문제를 상위 중요 개념으로부터 하위의 개념으로 구체화</li>
  <li>추상화의 반복에 의해 세분화
<br /><br />
4). <strong>정보 은닉</strong></li>
  <li>모듈 내부에 포함된 자료들의 정보가 감추어 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법</li>
  <li>필요한 정보만 인터페이스를 통해 주고 받음</li>
  <li>모듈의 독립적 수행 가능(다른 모듈에 영향x)
<br /><br /><br /><br /></li>
</ul>

<p><strong>소프트웨어 아키텍쳐의 품질 속성</strong></p>
<ul>
  <li>이해 관계잘들이 요구하는 수준의 품질을 유지 및 보장할 수 있게 설계되었는지 확인하기 위해 구분하여 구체화시켜 놓음</li>
  <li><strong>시스템 측면:</strong> 성능(이벤트 발생 시 빠르게 처리), 보안, 가용성(장애없이), 가능성, 사용성</li>
  <li><strong>비즈니스 측면:</strong> 시장 적시성, 비용, 예상 시스템 수명</li>
  <li><strong>아키텍처 측면:</strong> 개념적 무결성, 정확성, 구축 가능성
<br /><br />
<strong>아케텍처의 설계 과정</strong></li>
  <li>설계 목표 설정(개발 방향) -&gt; 시스템 타입 결정(아키텍처 패턴 선택) -&gt; 아키턱처 패턴 적용 -&gt; 서브시스템 구체화(상호작용을 위한 동작과 인터페이스 정의) -&gt; 검토
<br /><br />
—
—
    <h3 id="아키텍처-패턴아키텍처를-설계할-때-참조할-수-있는-전형적인-해결-방식-또는-예제">아키텍처 패턴(아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제)</h3>
  </li>
  <li>장점: 개발 시간 단축, 안정적 개발 가능, 의사소통 용이, 쉬운 유지보수, 시스템의 특성 예측 용이</li>
  <li>종류: 레이어 패턴, 클라이언트-서버 패턴, 파이프-필터 패턴, 모델-뷰-컨트롤러 패턴</li>
</ul>

<p>1) <strong>레이어 패턴</strong>: 서로 마주보는 두 개의 계층 사이에서만 상호작용
<br /><br />
2) <strong>클라이언트-서버 패턴</strong>: 서버는 항상 대기 상태 유지  <br />
<br /><br />
3) <strong>파이프-필터 패턴</strong>: 캡슐화 고로 재사용성 좋고 확장성이 있음
<br /><br />
4) <strong>모델-뷰-컨트롤러 패턴</strong>: 모델(데이터 보관), 뷰(정보 표시), 컨트롤러(상용자로부터 받은 입력을 처리) 
<br /><br /></p>

<hr />
<h3 id="객체지향">객체지향</h3>

<p><strong>객체지향의 구성요소</strong></p>
<ul>
  <li>객체: 데이터 + 연산</li>
  <li>메소드: 객체의 구체적인 연산을 정의</li>
  <li>클래스: 유사한 객체들을 모아 공통된 특성을 표현한 것. 클래스로부터 생성된 새로운 객체를 <code class="language-html highlighter-rouge">인스턴스</code>라고 한다.</li>
  <li>메세지: 메세지를 통해 객체의 동작이 수행.
<br /><br />
<strong>객체 지향기법</strong>
    <ul>
      <li>캡슐화: 정보은닉</li>
      <li>상속: 부모로부터 물려받는 것</li>
      <li>추상화: 단순화</li>
      <li>다형성: 고유한 방법으로 응답할 수 있는 능력</li>
    </ul>
  </li>
</ul>

<hr />
<h3 id="모듈">모듈</h3>

<ul>
  <li><strong>모듈화</strong>: 시스템의 기능들을 모듈 단위로 분해하는 것
    <ul>
      <li>모듈화는 독립성이 높아야 하고 독립성은 <code class="language-html highlighter-rouge">결합도</code>와 <code class="language-html highlighter-rouge">응집도</code>에 의해 측정된다.</li>
    </ul>
  </li>
</ul>

<h3 id="공통-모듈">공통 모듈</h3>
<ul>
  <li>전체 프로그램의 기능 중 공통적으로 사용할 수 있는 모듈
<br /><br />
<strong>공통 모듈 구현 시 명세 작성 원칙</strong>
    <ul>
      <li>정확성: 해당 기능이 필요하는 것을 정확히 작성</li>
      <li>명확성: 중의적 해석x</li>
      <li>완전성: 필요한 모든 것을 기술</li>
      <li>일관성: <code class="language-html highlighter-rouge">상호 출돌</code>이 발생하면 안된다.</li>
      <li>추적성: <code class="language-html highlighter-rouge">요구사항의 출처</code>, 관계 파악할 수 있도록 작성 
<br /><br /></li>
    </ul>
  </li>
</ul>

<hr />
:ET