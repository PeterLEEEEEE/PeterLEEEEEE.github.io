I"X<hr />

<h3 id="트리tree">트리(tree)</h3>

<p>앞서 다뤘던 리스트, 스택, 큐 등은 <strong>선형 자료구조</strong>(1:1)이다.</p>

<p>이에 반해 <strong>트리</strong>는 계층적인 구조를 나타내는 <strong>비선형 자료구조</strong>이다.</p>

<p>정리하면 트리는</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>- 원소들 간에 1:N 관계를 가지는 비선형 자료구조
- 원소들 간에 계층 관계를 가지는 구조(부모-자식 구조)이다.
</code></pre></div></div>

<hr />

<h5 id="트리-용어">트리 용어</h5>
<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>- 루트(root) 노드: 트리의 첫 번째 노드(2번 노드에 해당)
- 단말(leap or terminal) 노드: 자식이 없는 노드(5, 11, 4번 노드가 해당)
- 내부(internal) 노드: 적어도 하나의 자식을 가지는 노드(단말 노드가 아닌 노드)
- 트리의 높이(height): 루트 노드에서 가장 먼 거리에 있는 자식 노드에 이르는 간선들의 수
- 차수(degree): 한 노드가 가지는 자식 노드의 개수
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/52132160/88499076-d5df1b00-cfff-11ea-820d-f2930155a4a8.png" alt="300px-Binary_tree svg" /></p>

<hr />

<h4 id="이진-트리binary-tree">이진 트리(binary tree)</h4>
<ul>
  <li>
    <p>트리의 모든 노드의 차수를 2 이하로 제한하는 트리 형식</p>
  </li>
  <li>이진 트리의 모든 노드는 왼쪽 자식 노드와 오른쪽 자식 노드만을 가짐
    <ul>
      <li>0 &lt;= 노드의 차수 &lt;= 2</li>
    </ul>
  </li>
  <li>
    <p>노드의 개수가 n개 이면 간선의 개수는 n-1개이다.</p>
  </li>
  <li>높이가 h인 이진 트리의 경우
    <ul>
      <li>최소 h개의 노드 ~ 최대 \(2^h - 1\) 개의 노드</li>
    </ul>
  </li>
  <li>n개의 노드를 가지는 이진 트리의 높이
    <ul>
      <li>최소 \(log2(n+1)\) ~ 최대 n</li>
    </ul>
  </li>
</ul>

<hr />

<h5 id="이진-트리의-분류">이진 트리의 분류</h5>
<ol>
  <li>포화 이진 트리(full binary tree): 단말 노드를 제외한 모든 노드가 2개의 자식 노드을 가짐</li>
  <li>완전 이진 트리(complete binary tree): 왼쪽부터 순서대로 채워진 트리</li>
  <li>편향 이진 트리: 노드가 왼쪽 또는 오른쪽 한 방향으로만 서브 트리를 가진 트리</li>
  <li>기타 이진 트리</li>
</ol>

<p><img src="https://user-images.githubusercontent.com/52132160/88501438-6c163f80-d006-11ea-9e0a-c14275219b52.PNG" alt="이진트리2" /></p>

<h5 id="연결리스트를-이용한-이진-트리c">연결리스트를 이용한 이진 트리.c</h5>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="nc">Node</span><span class="o">*</span> <span class="n">left</span><span class="p">;</span>
	<span class="k">struct</span> <span class="nc">Node</span><span class="o">*</span> <span class="n">right</span><span class="p">;</span>
<span class="p">}</span><span class="n">Node</span><span class="p">;</span></code></pre></figure>

<p><img src="https://user-images.githubusercontent.com/52132160/88502963-20b26000-d00b-11ea-8886-e95ab01c2190.PNG" alt="포인터 이진트리" />
<img src="https://user-images.githubusercontent.com/52132160/88503036-666f2880-d00b-11ea-83a6-6ca2bccb21bb.PNG" alt="포인터 이진트리2" /></p>

<p>Node* Init(char data) {
	Node* newNode = (Node*)malloc(sizeof(Node));
	newNode-&gt;data = data;
	newNode-&gt;left = NULL;
	newNode-&gt;right = NULL;
	return newNode;
}</p>

<p>//전위
void preorder(Node* p) {
	if (p == NULL) return;</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>printf(" %c ", p-&gt;data);
preorder(p-&gt;left);
preorder(p-&gt;right); }
</code></pre></div></div>

<p>//중위
void inorder(Node* p) {
	if (p == NULL) return;</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="syntax"><code>inorder(p-&gt;left);
printf(" %c ", p-&gt;data);
inorder(p-&gt;right);
</code></pre></div></div>

<p>}</p>
:ET