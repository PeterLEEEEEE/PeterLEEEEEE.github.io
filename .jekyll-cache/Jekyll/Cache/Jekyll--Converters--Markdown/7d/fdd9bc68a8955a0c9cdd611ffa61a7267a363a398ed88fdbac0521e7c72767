I"SH<hr />

<h3 id="그래프graph">그래프(graph)</h3>

<ul>
  <li>트리가 1:n 구조의 자료구조 였다면 그래프는 n:n 구조의 자료구조이다.</li>
  <li>
    <p>그래프의 G는 (V, E)로 표시하는데, 이는 객체를 나타내는 <strong>정점(vertex)</strong>과 객체를 연결하는 <strong>간선(edge)</strong>으로 구성되어 있다.</p>
  </li>
  <li>정점(vertex): – 노드라고도 불림
    <ul>
      <li>여러 가지 특성을 가질 수 있는 객체를 의미</li>
      <li>V(G): 그래프 G의 정점들의 집합</li>
    </ul>
  </li>
  <li>간선(edge): – 링크
    <ul>
      <li>정점들 간의 관계 의미</li>
      <li>E(G): 그래프 G의 간선들의 집합
<img src="https://user-images.githubusercontent.com/52132160/88883052-44c1ab80-d26e-11ea-9760-43423be7f747.png" alt="image" /></li>
    </ul>
  </li>
</ul>

<h5 id="그래프의-종류">그래프의 종류</h5>

<ol>
  <li>무방향 그래프(undirected graph)
    <ul>
      <li>두 정점을 연결하는 간선에 방향이 없는 그래프</li>
      <li>정점 Vi와 Vj를 연결하는 간선을 (Vi, Vj)라고 나타낸다.
 <strong>(Vi, Vj) = (Vj, Vi)</strong>
<img src="https://user-images.githubusercontent.com/52132160/88881887-8f8df400-d26b-11ea-8153-bab577d4511f.png" alt="image" />
<img src="https://user-images.githubusercontent.com/52132160/88881911-a0d70080-d26b-11ea-8272-5f87d13aebc8.png" alt="image" /></li>
    </ul>
  </li>
  <li>방향 그래프(directed graph), digraph
    <ul>
      <li>간선에 방향이 있는 그래프</li>
      <li>정점 Vi에서 Vj를 연결하는 간선 즉, Vi -&gt; Vj를 &lt;Vi, Vj&gt; 로 표현
        <ul>
          <li>Vi를 tail, Vj를 head 라고 한다.</li>
          <li><strong>&lt;Vi, Vj&gt;와 &lt;Vj, Vi&gt;</strong>는 서로 다른 간선이다.   <br />
<img src="https://user-images.githubusercontent.com/52132160/88882128-3a061700-d26c-11ea-94ff-c1ed69827eec.png" alt="image" /></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>가중치 그래프(weighted graph), 네트워크
    <ul>
      <li>간선에 비용(cost)이나 가중치(weight)가 할당된 그래프
<img src="https://user-images.githubusercontent.com/52132160/88882569-3aeb7880-d26d-11ea-9589-49e5e5a66585.png" alt="image" /></li>
    </ul>
  </li>
</ol>

<ul>
  <li>etc. 완전 그래프(complete graph), 부분 그래프(subgraph)등 이 존재한다.</li>
</ul>

<hr />

<hr />

<h4 id="그래프의-구현">그래프의 구현</h4>
<ul>
  <li>무방향, 방향 그래프 모두 <strong>인접 행렬</strong>과 <strong>인접 리스트</strong> 두 가지 방법을 통해 구현 가능하다.</li>
  <li>나는 화살표로 고통받는 걸 좋아하기 때문에 인접 리스트로 구현해 보았다.</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/52132160/88883876-5015d680-d270-11ea-9b6c-286ab90e1ac7.png" alt="image" /><a name="footnote_1"></a>:무방향 그래프 인접리스트 표현
<img src="https://user-images.githubusercontent.com/52132160/88884514-bf3ffa80-d271-11ea-85b7-d21596143572.png" alt="image" />
<a name="footnote_1"></a>:방향 그래프 인접리스트 표현</p>

<h4 id="무방향-그래프c">무방향 그래프.c</h4>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define MAX_VERTEX 30                   // 헤드 포인터 배열의 최대 크기
</span>
<span class="c1">// 인접 리스트의 노드 구조를 구조체로 정의</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">graphNode</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">vertex</span><span class="p">;</span>                         <span class="c1">// 정점을 나타내는 데이터 필드</span>
    <span class="k">struct</span> <span class="nc">graphNode</span><span class="o">*</span> <span class="n">link</span><span class="p">;</span>             <span class="c1">// 다음 인접 정점을 연결하는 링크 필드</span>
<span class="p">}</span> <span class="n">graphNode</span><span class="p">;</span>

<span class="c1">// 그래프를 인접 리스트로 표현하기 위한 구조체 정의</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">graphType</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>                              <span class="c1">// 그래프의 정점 개수</span>
    <span class="n">graphNode</span><span class="o">*</span> <span class="n">adjList_H</span><span class="p">[</span><span class="n">MAX_VERTEX</span><span class="p">];</span>   <span class="c1">// 그래프 정점에 대한 헤드 포인터 배열</span>
<span class="p">}</span> <span class="n">graphType</span><span class="p">;</span>

<span class="c1">// 공백 그래프를 생성하는 연산</span>
<span class="kt">void</span> <span class="nf">createGraph</span><span class="p">(</span><span class="n">graphType</span><span class="o">*</span> <span class="n">g</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">v</span><span class="p">;</span>
    <span class="n">g</span><span class="o">-&gt;</span><span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                           <span class="c1">// 그래프의 정점 개수를 0으로 초기화</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">v</span><span class="o">&lt;</span><span class="n">MAX_VERTEX</span><span class="p">;</span> <span class="n">v</span><span class="o">++</span><span class="p">)</span>
        <span class="n">g</span><span class="o">-&gt;</span><span class="n">adjList_H</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>         <span class="c1">// 그래프의 정점에 대한 헤드 포인터 배열을 NULL로 초기화</span>
<span class="p">}</span>

<span class="c1">// 그래프 g에 정점 v를 삽입하는 연산</span>
<span class="kt">void</span> <span class="nf">insertVertex</span><span class="p">(</span><span class="n">graphType</span><span class="o">*</span> <span class="n">g</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(((</span><span class="n">g</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">&gt;</span><span class="n">MAX_VERTEX</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s"> 그래프 정점의 개수를 초과하였습니다!"</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">g</span><span class="o">-&gt;</span><span class="n">n</span><span class="o">++</span><span class="p">;</span>                             <span class="c1">// 그래프의 정점 개수 n을 하나 증가</span>
<span class="p">}</span>

<span class="c1">// 그래프 g에 간선 (u, v)를 삽입하는 연산</span>
<span class="kt">void</span> <span class="nf">insertEdge</span><span class="p">(</span><span class="n">graphType</span><span class="o">*</span> <span class="n">g</span><span class="p">,</span> <span class="kt">int</span> <span class="n">u</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">graphNode</span><span class="o">*</span> <span class="n">node</span><span class="p">;</span>

    <span class="c1">// 간선 (u, v)를 삽입하기 위해 정점 u와 정점 v가 현재 그래프에 있는지 확인</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">&gt;=</span> <span class="n">g</span><span class="o">-&gt;</span><span class="n">n</span> <span class="o">||</span> <span class="n">v</span> <span class="o">&gt;=</span> <span class="n">g</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s"> 그래프에 없는 정점입니다!"</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">node</span> <span class="o">=</span> <span class="p">(</span><span class="n">graphNode</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">graphNode</span><span class="p">));</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">vertex</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">link</span> <span class="o">=</span> <span class="n">g</span><span class="o">-&gt;</span><span class="n">adjList_H</span><span class="p">[</span><span class="n">u</span><span class="p">];</span>   <span class="c1">// 삽입 간선에 대한 노드를 리스트의 첫 번째 노드로 연결</span>
    <span class="n">g</span><span class="o">-&gt;</span><span class="n">adjList_H</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 그래프 g의 각 정점에 대한 인접 리스트를 출력하는 연산</span>
<span class="kt">void</span> <span class="nf">print_adjList</span><span class="p">(</span><span class="n">graphType</span><span class="o">*</span> <span class="n">g</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">graphNode</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">g</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n\t\t</span><span class="s">정점 %c의 인접 리스트"</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">65</span><span class="p">);</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">g</span><span class="o">-&gt;</span><span class="n">adjList_H</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">" -&gt; %c"</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">vertex</span> <span class="o">+</span> <span class="mi">65</span><span class="p">);</span> <span class="c1">// 정점 0~3을 A~D로 출력</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">link</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="n">graphType</span> <span class="o">*</span><span class="n">G1</span><span class="p">,</span> <span class="o">*</span><span class="n">G2</span><span class="p">,</span> <span class="o">*</span><span class="n">G3</span><span class="p">,</span> <span class="o">*</span><span class="n">G4</span><span class="p">;</span>
    <span class="n">G1</span> <span class="o">=</span> <span class="p">(</span><span class="n">graphType</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">graphType</span><span class="p">));</span>
    <span class="n">G2</span> <span class="o">=</span> <span class="p">(</span><span class="n">graphType</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">graphType</span><span class="p">));</span>
    <span class="n">G3</span> <span class="o">=</span> <span class="p">(</span><span class="n">graphType</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">graphType</span><span class="p">));</span>
    <span class="n">G4</span> <span class="o">=</span> <span class="p">(</span><span class="n">graphType</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">graphType</span><span class="p">));</span>
    <span class="n">createGraph</span><span class="p">(</span><span class="n">G1</span><span class="p">);</span> <span class="n">createGraph</span><span class="p">(</span><span class="n">G2</span><span class="p">);</span> <span class="n">createGraph</span><span class="p">(</span><span class="n">G3</span><span class="p">);</span> <span class="n">createGraph</span><span class="p">(</span><span class="n">G4</span><span class="p">);</span>

    <span class="c1">// 그래프 G1</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">insertVertex</span><span class="p">(</span><span class="n">G1</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>    <span class="c1">// G1의 정점 0~3 삽입</span>
    <span class="n">insertEdge</span><span class="p">(</span><span class="n">G1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">insertEdge</span><span class="p">(</span><span class="n">G1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">insertEdge</span><span class="p">(</span><span class="n">G1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">insertEdge</span><span class="p">(</span><span class="n">G1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">insertEdge</span><span class="p">(</span><span class="n">G1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">insertEdge</span><span class="p">(</span><span class="n">G1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">insertEdge</span><span class="p">(</span><span class="n">G1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">insertEdge</span><span class="p">(</span><span class="n">G1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">insertEdge</span><span class="p">(</span><span class="n">G1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">insertEdge</span><span class="p">(</span><span class="n">G1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s"> G1의 인접 리스트"</span><span class="p">);</span>
    <span class="n">print_adjList</span><span class="p">(</span><span class="n">G1</span><span class="p">);</span>

	<span class="cm">/*
    // 그래프 G2
    for (i = 0; i&lt;3; i++)
        insertVertex(G2, i);    // G2의 정점 0~2 삽입
    insertEdge(G2, 0, 2);
    insertEdge(G2, 0, 1);
    insertEdge(G2, 1, 2);
    insertEdge(G2, 1, 0);
    insertEdge(G2, 2, 1);
    insertEdge(G2, 2, 0);
    printf("\n\n G2의 인접 리스트");
    print_adjList(G2);

    // 그래프 G3
    for (i = 0; i&lt;4; i++)
        insertVertex(G3, i);    // G3의 정점 0~3 삽입
    insertEdge(G3, 0, 3);
    insertEdge(G3, 0, 1);
    insertEdge(G3, 1, 3);
    insertEdge(G3, 1, 2);
    insertEdge(G3, 2, 3);
    printf("\n\n G3의 인접 리스트");
    print_adjList(G3);

    // 그래프 G4
    for (i = 0; i&lt;3; i++)
        insertVertex(G4, i);    // G4의 정점 0~2 삽입
    insertEdge(G4, 0, 2);
    insertEdge(G4, 0, 1);
    insertEdge(G4, 1, 2);
    insertEdge(G4, 1, 0);
    printf("\n\n G4의 인접 리스트");
    print_adjList(G4);
*/</span>
	
    <span class="n">getchar</span><span class="p">();</span>
<span class="p">}</span></code></pre></figure>

<hr />

:ET