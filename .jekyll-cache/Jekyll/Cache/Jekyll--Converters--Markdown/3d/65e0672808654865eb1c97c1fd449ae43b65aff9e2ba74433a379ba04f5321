I""<hr />

<p><br /><br /></p>

<h2 id="io-system입출력-시스템">I/O System(입출력 시스템)</h2>

<p>컴퓨터의 주요 작업을 꼽으라면 계산과 입출력 작업을 들 수 있다.
운영체제는 입출력 시 입출력 작업 및 입출력 장치를 관리하고 제어한다.</p>

<p>I/O는 device와 컨트롤러의 버퍼 사이에서의 데이터 흐름이다.(CPU는 컨트롤러의 버퍼와 메인 메모리를 오가며 데이터를 읽어낸다.), 컨트롤러 하나가 여러 장치를 담당하기도 한다.
<br /></p>

<ul>
  <li>각 하드웨어에는 컨트롤러라는 것이 존재하는데, 일종의 작은 CPU로 하드웨어를 제어한다. 그리고 이 컨트롤러 안에는 데이터를 임시로 저장하는 작은 메모리 공간을 가지고 있으며 이를 Local Buffer(버퍼)라고 한다.
<br />
<br /></li>
</ul>

<h2 id="io-operations">I/O Operations</h2>

<hr />

<p>입출력 전송을 위해서 처리기는 명령어와 데이터를 컨트롤러에 전달해야 하는데 여러 가지 방법들이 존재한다.</p>

<p><strong>1.Memory Mapped I/O</strong> <br />
앞에서 컨트롤러를 언급하며 버퍼를 가지고 있다고 하였는데 사실 레지스터도 가지고 있다.
<br />
그래서 본체의 프로세서는 컨트롤러의 레지스터에 비트 패턴을 쓰거나 읽으며 입출력을 수행하게 되고 이 방법 중 하나는 바로 <strong>특별한 입출력 명령어</strong>를 사용하는 것이다.
입출력 명령어는 한 바이트나 워드를 어떤 입출력 포트 주소로 전달하도록 지정한다.
<br />
쉽게 설명하면 buffer에 주소를 통해 접근하는 방법이다.
이 방법은 메모리에 기록하는 것이 매번 입출력 명령어를 사용하는 것보다 빠르기에 현재의 I/O는 대부분 이 방식을 채택한다.
<br /></p>

<p><strong>2.Special I/O:</strong><br />
port I/O라는 특수한 명령어 제공 <br />
장점: 메모리 주소를 공유하지 않는다(메모리맵드는 메모리 접근, I/O 접근에 동일한 명령어를 사용)<br />
단점: 명령어를 구축해야하는 부담이 생긴다.</p>

<p><strong>3.Polling I/O(Programmed I/O)</strong><br /></p>

<ul>
  <li>모든 입출력 작업을 CPU 명령어를 이용한다.</li>
  <li>CPU는 계속해서 입출력 장치의 상태를 확인한다.
문제점: <br />
CPU가 버퍼를 계속 확인(= polling)해야 하므로 비효율적이다.(polling을 하느라 다른 작업을 제대로 수행하지 못함.)<br />
장치의 제한된 버퍼로는 CPU의 도움이 없다면 오버플로우가 발생할 확률이 높다.
<br />
<br />
<strong>- Polling</strong><br />
컨트롤러는 상태 레지스터의 비지 비트를 통해 자신의 상태를 나타냄(바쁠때 1, 다음 명령 대기 = 0), 호스트는 명령 레지스터의 명령 준비 완료 비트(command-read bit)를 통해 입출력을 원한다는 신호를 함.<br /><br />
호스트는 다음과 같은 방법으로 핸드셰이킹을 통해 컨트롤러와 협력하며 포트를 통해 출력한다.
<br /><br />
–&gt; CPU가 상태 레지스터의 비지 비트가 0이 될때까지 검사<br />
–&gt; CPU는 명령 레지스터의 write bit를 설정하고 data-out(출력) register에 보낼 데이터를 써줌<br />
–&gt; CPU는 control register안의 command-ready bit을 설정<br />
–&gt; 장치 컨트롤러가 command-ready bit의 설정을 발견하고 자신의 비지 비트 설정<br />
–&gt; 장치 컨트롤러는 명령 레지스터를 읽고 쓰기 명령임을 판단, 출력 레지스터를 읽어 장치로 출력한다.<br />
–&gt; 장치 컨트롤러는 command-ready bit를 0으로 하고 입출력이 성공했음을 알리기 위해 상태 레지스터의 오류 비트를 0으로 바꾸고, 입출력도 완료하였으니 비지 비트도 0으로 바꾼다.<br /></li>
</ul>

<p>여기서 CPU는 첫번째 과정에서 비지 비트가 소거될 때까지 루프를 돌며 검사를 반복한다(이 과정이 <strong>polling</strong>이다). 그리고 이 시간이 길어지면 매우 비효율적일 것이며 몇몇 장치들은 호스트가 빨리 서비스해주지 않으면 데이터는 계속 들어오는데 막상 CPU는 하드웨어가 동작이 끝날 때까지 상태를 체크하니 다른 처리가 계속 미뤄지고 오버플로우를 일으키게 될 것이다.
<br /><br />
이런 비효율적인 상황을 보완하기 위해 생겨난 것이 바로 <strong>Interrupt</strong>이다. 이는 입출력 장치가 CPU에 자신의 상태 변화를 통보하는 하드웨어 기법이다.(반복적인 폴링보다 하드웨어 컨트롤러가 자신의 상태가 바뀔 때 CPU에 통보하는 것이 더 효율적)
<br /><br /></p>

<h2 id="interrupt">Interrupt</h2>

<hr />

<p>인터럽트(Interrupt)란 CPU가 처리 중에 있을 때, 입출력 하드웨어 장치나 다른 예외적 상황의 발생으로 처리가 필요한 상황에 CPU를 불러 처리하도록 하는 것이다.<br />
‘장치 컨트롤러가 인터럽트를 걸면 CPU는 이를 캐치’
<br /></p>

<p>즉 치킨을 주문해놓고 문 앞에서 목빠지게 기다렸던 것이 polling 방식이라면, 치킨이 튀겨지는 동안 은행 등의 다른 볼일을 보다가 치킨 집에서 연락이 오면(인터럽트) 맞춰서 찾아가는 효율적인 방식이라고 생각하면 편할 것 같다.
<br /><br /></p>

<p>CPU는 <strong>IRQ(Interrupt ReQuest) Line</strong>을 가지고 있는데, 하나의 명령어의 실행을 완료할 때마다 항상 이 선을 검사한다. 컨트롤러가 이 라인에 신호를 보내면 CPU는 하던 일을 잠깐 멈추고 현재 작업 내용을 Context에 잠깐 저장한 상태로 Interrupt handling을 하게 된다. 처리가 끝나면 context를 다시 불러와 작업을 재개한다.
<br />
<strong>Interrupt handling</strong> <br /></p>
<ul>
  <li>시스템 스택에 context를 저장해놓고 일이 끝나면 pop시켜 다시 작업을 한다. <br />
Polling: 비효율적 <br />
<strong>Vectored interrupt system:</strong> 가장 많이 쓰이는 방식으로 IRQ에 벡터 값을 넣어서 분기한다.</li>
</ul>

<p><br />
<br /></p>

<h2 id="dmadirect-memory-access">DMA(Direct Memory Access)</h2>

<hr />

<p>고속 장치에서 들어오는 인터럽트는 CPU에게 부담을 준다. 그래서 부담을 덜어주기 위한 대행자를 만들었는데 그것이 DMA이다. <br />
<br />
역할: 대용량의 벌크 데이터를 장치와 메모리 사이에 놓고 CPU가 개입하지 않고 대행해준다.
<br />
만약 DMA가 없다면 CPU에게 매 바이트마다 인터럽트가 들어올 것이다.</p>

<p><strong>2. Batch processing systems</strong> <br />
작은 크기의 단순한 OS였으며 디스크 관리 시스템이었다.
Offline processing 방식이었는데, 당시 컴퓨터가 굉장히 고가였고 기술적인 한계도 존재하였기에 처리할 내용들(카드)을 모아서 한꺼번에 처리하는 방식이었다.(OMR 카드 리딩이랑 비슷)
추후에 마그네틱 테잎으로 대체되었으며 퍼포먼스는 카드 리더기의 성능에 따라 달랐다.</p>

<p><strong>3. Multi-programming system</strong> <br />
멀티프로그래밍 시스템의 가장 큰 특징은 바로 프로그램이 concurrently하게 처리된다는 점이다. <br />
이를 다른 표현으로 <strong>IO/CPU Overlap</strong>이라고 부르는데 CPU처리가 출력 처리보다 매우 빨랐고, 당시 고가의 컴퓨터를 더 효율적으로 사용하기 위해 고안된 방법이다.
<br />
CPU가 처리한 데이터를 출력 장치에 보낸 후 CPU는 다른 명령어를 처리하게끔 하는 것이다.
즉 데이터의 입출력이 진행되면서 동시에 CPU의 처리가 가능하게 된 것이다.
<br /><br />
<strong>한계:</strong> 아직은 리더기에 의한 처리 즉 Offline 처리였고, 하나의 처리가 모두 끝나야 다음 프로그램으로 넘어갈 수 있었다.</p>

<p><strong>4. Time-Sharing system</strong> <br />
Online 프로세싱이 가능해졌고 Terminal이 생기며 CPU와 통신으로 연결됨(터미널을 통해 유저와 컴퓨터가 소통)
<strong>Time-Sharing</strong>이라는 방식이 도입 되었는데, 이는 기존의 방식이 프로그램의 크기에 따라 Response time이 들쭉날쭉하였으나 Time slice를 만들어 모든 프로세스가 일정한 시간만큼 동등하게 할당받아 사용하는 방식이다. 이로서 Response time 간격이 짧아졌다(Round-Robin Scheduling)</p>

<p><strong>5. 1980 이후</strong> <br />
반도체 기술의 발전으로 멀티 프로세서, 스토리지, PC의 등장으로 CPU의 하중이 많이 줄어 들었다.(계산량 분산)</p>

<p><br /></p>

<hr />

<hr />
:ET