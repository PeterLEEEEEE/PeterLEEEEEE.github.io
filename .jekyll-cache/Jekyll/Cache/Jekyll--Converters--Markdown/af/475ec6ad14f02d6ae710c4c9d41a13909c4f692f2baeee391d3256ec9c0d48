I"!<hr />

<h3 id="소프트웨어-패키징">소프트웨어 패키징</h3>

<p><strong>개요</strong>: 모듈별로 생성한 실행 파일들을 묶어 배포용 설치 파일을 만드는 것
<br /><br /> - <code class="language-html highlighter-rouge">모듈의 개수 = 기능의 개수</code></p>
<ul>
  <li>패키징은 철저히 사용자 중심으로 진행
<br /><br />
<strong>고려사항</strong>: OS, CPU, 메모리, 최소환경, 매뉴얼, 고객 편의
<br /><br />
<strong>패키징 작업 순서</strong>
    <ul>
      <li>보통 2~4주 내에서 지정, 주기가 끝날 때마다 패키징 수행</li>
      <li>
        <font size="3">기능 식별 -&gt; 모듈화 -&gt; 빌드 진행 -&gt; 사용자 환경 분석 -&gt; 패키징 및 적용 시험 -&gt; 패키징 변경 개선 -&gt; 배포</font>
        <p><br /><br /></p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="디지털-저작권-관리drm">디지털 저작권 관리(DRM)</h3>

<ul>
  <li>저작권: 저작물에 대해 저작자가 가지는 배타적 독점적 권리</li>
  <li>DRM: 저작권자가 배포한 디절털 콘텐츠가 저작권자가 의도한 용도로만 사용되도록 디지털 콘텐츠의 생성, 유통, 이용까지의 전 과정에 결쳐 사용되는 디지털 콘텐츠 관리 및 보호 기술.
 <br /><br /></li>
</ul>

<p><strong>DRM의 구성</strong></p>
<ul>
  <li>클리어링하우스: 라이센스 관리, 발급, 결제 관리</li>
  <li>패키저: 컨텐츠를 메타 데이터와 함께 배포 가능한 형태로 묵어 암호화하는 프로그램</li>
  <li>DRM 컨트롤러: 배포된 컨텐츠의 이용 권한을 통제하는 프로그램</li>
  <li>보안 컨테이너: 컨텐츠 원본을 안전하게 유통하기 위한 전자적 보안 장치</li>
</ul>

<h3 id="소프트웨어-버전-등록">소프트웨어 버전 등록</h3>

<p><strong>소프트웨어 패키징의 형상 관리</strong>: 소프트웨어의 변경 사항을 관리하기 위해 개발된 일련의 활동</p>
<ul>
  <li>형상관리의 특징: 관리/추적 가능, 개발의 진행정도 확인, 오류 및 변경 방지 -&gt; <code class="language-html highlighter-rouge">비용 감소, 오류 최소화</code></li>
</ul>

<p><strong>버전 관리 도구</strong></p>
<ul>
  <li>공유 폴더 방식</li>
  <li>클라이언트/서버 방식(SVN)</li>
  <li>분산 저장소 방식(Git): Local에서 버전관리를 할 수 있기 때문에, Local 선 반영 후 이를 원격 저장소에 반영함.</li>
</ul>

<hr />
<h3 id="빌드-자동화-도구">빌드 자동화 도구</h3>

<p><strong>Jenkins</strong></p>
<ul>
  <li>JAVA 기반의 오픈 소스 형태</li>
  <li>SVN, Git 등 대부분의 형상 관리 도구와 연동 가능<br /><br /></li>
  <li>Web GUI 제공, 여러 대의 컴퓨터를 이용한 분산 빌드나 테스트 가능
<strong>Gradle</strong></li>
  <li>Groovy 기반의 오픈 소스 형태의 자동화 도구</li>
  <li>안드로이드, JAVA, C/C++ 등의 언어도 빌드 가능</li>
  <li>Groovy를 사용하여 만든 DSL(Domain Specific Language)을 스크립트 언어로 사용</li>
  <li>실행할 처리 명령들을 모아 태스크로 만든 후 <code class="language-html highlighter-rouge">태스크 단위</code>로 실행 <br /><br /></li>
</ul>

<hr />

<h3 id="어플리케이션-테스트">어플리케이션 테스트</h3>

<p><strong>왜 테스트를 할까?</strong></p>
<ul>
  <li>잠재적 결함이나 고객의 요구사항을 만족시켜 신뢰도를 높일 수 있기 때문이다.</li>
</ul>

<p><strong>테스트의 기본 원리</strong></p>
<ul>
  <li>완벽한 소프트웨어 테스팅은 불가능하다.</li>
  <li><code class="language-html highlighter-rouge">파레토 법칙(80%의 오류는 20%의 모듈에서 발생)</code>에 따르기도 한다.</li>
  <li><code class="language-html highlighter-rouge">살충제 역설</code> 현상 보완: 테스트 케이스를 지속적으로 보완 및 개선</li>
  <li>오류 부재의 궤변: 오류가 없어도 사용자의 요구사항을 만족시키지 못하면 품질이 높다고 할 수 없다. <br /><br /></li>
</ul>

<h3 id="테스트-분류">테스트 분류</h3>

<p><strong>프로그램 실행 여부에 따른 테스트</strong></p>
<ul>
  <li>정적 테스트: 명세서나 소스 코드를 대상으로 분석</li>
  <li>동적 테스트: 프로그램을 실행하여 오류를 찾는 테스트
   <br /><br /></li>
</ul>

<p><strong>테스트 기반</strong></p>
<ul>
  <li>명세 기반 테스트: 요구사항에 대한 명세를 테스트케이스로 만들어 테스트</li>
  <li>구조 가반 테스트: SW 내부의 논리 흐름에 때라 테스트 케이스를 작성 후 테스트</li>
  <li>경험 기반 테스트: 테스트 경험을 기반으로 수행하는 테스트(명세 불충분, 시간이 부족할 때 사용)
<br /><br />
<strong>시각에 따른 테스트</strong></li>
  <li>검증 테스트: 의도한 기능이 완성됐는지</li>
  <li>확인 테스트: 요구한대로 제품이 완성됐는지
<br /><br /></li>
</ul>

<p><strong>목적에 따른 테스트</strong></p>
<ul>
  <li>회복(잘 복귀 되는지)</li>
  <li>안전(보호가 잘 이루어지는지)</li>
  <li>강도(과부하 시에도 잘 실행되는지)</li>
  <li>성능(응답 시간, 처리량)</li>
  <li>구조(복잡도 여부 테스트)</li>
  <li>회귀(수정된 코드에 새로운 결함이 있는지)</li>
  <li>병행(변경 소프트웨어와 기존 소프트웨어에 동일한 입력을 주어 결과 비교)<br /><br /></li>
</ul>

<hr />

<h3 id="개발-단계에-따른-어플리케이션-테스트">개발 단계에 따른 어플리케이션 테스트</h3>
<ul>
  <li><strong>단위(모듈) 테스트</strong>:
    <ul>
      <li>소프트웨어를 구현한 뒤 가장 먼저 진행되는 테스트</li>
      <li>구조 기반(White box), 명세 기반(black box) 테스트로 진행
<br /><br /></li>
    </ul>
  </li>
  <li><strong>통합 테스트</strong>:
    <ul>
      <li>모듈 간의 상호작용 오류를 검사</li>
      <li>비점진적 방식(한번에 통합)과 점진적 방식(단계적 통합)이 있음
        <ul>
          <li>
            <font size="3">점진적 방식은 하향식 통합 테스트의 깊이 우선 통합과 너비 우선 통합이 존재한다</font>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /><br /></p>
<ul>
  <li><strong>시스템 테스트</strong>:
    <ul>
      <li>기능적 요구사항(black box test), 비기능적 요구사항(White box test)으로 구분하여 만족하는 지 테스트
<br /><br /></li>
    </ul>
  </li>
  <li><strong>인수 테스트</strong>:
    <ul>
      <li>개발한 소프트웨어가 사용자의 요구사항을 충족하는지에 중점을 두고 테스트</li>
      <li>개발한 소프트웨어를 사용자가 직접 테스트한다.</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="어플리케이션-테스트-프로세스">어플리케이션 테스트 프로세스</h3>
<p><br /><br />
1) 테스트 계획: 시스템 구조 파악, 테스트 비용 산정, 시작 및 종료 조건 정의
2) 설계(분석 및 디자인): 사용자의 요구사항 분석, 리스크 분석 및 우선순위 결정<br />
3) 시나리오 작성: 테스트용 스크립트 작성
4) 테스트 수행: 테스트의 실행 결과를 측정하여 기록
5) 결과 평가 및 리포팅
6) 결함 추적 및 관리</p>

<hr />

<h3 id="테스트-자동화-도구">테스트 자동화 도구</h3>
<p>장점) 자원 소모 감소, 품질 보장, 일관적
단점) 교육 및 학습을 위한 자원이 필요, 상용 도구의 경우 추가 비용 필요
<br /><br /></p>
<h3 id="결함-관리">결함 관리</h3>
<p><strong>결함 관리 프로세스</strong><br />
계획 -&gt; 기록 -&gt; 검토 -&gt; 수정 -&gt; 재확인 -&gt; 보고서 작성
<br /><br />
<strong>결함 추적 순서</strong><br />
등록 -&gt; 검토 -&gt; 할당 -&gt; 수정 -&gt; 보류 -&gt; 종료 -&gt; 해제
<br /><br /></p>

<p><strong>결함의 분류</strong><br /></p>
<ol>
  <li>시스템 결함: 어플리케이션 및 DB의 결함</li>
  <li>기능 결함: 프로세스와 결과 등이 불일치</li>
  <li>GUI 결함: 화면의 특정 정보에 대한 표시 오류</li>
  <li>문서 결함: 문서, 매뉴얼의 불일치와 의사소통이 원활하지 않아 발생된 결함
<br /><br /></li>
</ol>

<hr />
:ET