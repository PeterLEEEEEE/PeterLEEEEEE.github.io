I"$<hr />

<ul>
  <li>공룡책 10판(Operating System Concepts 10th)과 수업 내용을 참고로 한 내용 정리이다.</li>
  <li>정리 목적 그리고 배우는 입장의 포스팅이기에 잘못된 내용이 있을 수 있다.</li>
</ul>

<hr />

<p><br /><br /></p>

<h2 id="scheduling스케줄링의-개요">Scheduling(스케줄링)의 개요</h2>

<p>운영체제의 핵심을 두 가지로 나타내면 메모리 관리 그리고 프로세스 관리라는 점을 알 수 있다. <br />
스케줄링은 이 중에서 프로세스 관리에 속하니 당연히 중요할 수 밖에 없다.
<br /><br />
그렇다면 스케줄링이란 무엇일까? 스케줄링은 다음에 어떤 프로세스를 실행시킬 것인지를 결정하는 과정이다. 실행 가능한 프로세스들이 여러 개 존재할 때, 그 중에서 어떤 프로세스를 선택하여 CPU를 할당할 것인지를 스케줄링 알고리즘을 통해 정한다.
<br />
<br />
이러한 스케줄링은 자주 일어나기 때문에 오래 걸리면 안된다.</p>

<p><br />
  <br /></p>

<h2 id="스케줄링-알고리즘의-목표">스케줄링 알고리즘의 목표</h2>

<hr />

<p><strong>Starvation 방지</strong> <br />
Starvation이란 프로세스가 우선순위(priority)에 밀려 CPU 자원을 할당받지 못하고 계속해서 기다리는 현상을 말한다.</p>

<p><strong>공평성 제공</strong> <br />
같은 우선순위의 프로세스들에게 CPU 자원을 공평하게 제공하도록 한다.
<br /></p>

<p><strong>균형성</strong> <br />
CPU와 I/O가 균형되게 사용될 수 있도록 하는 것이다. 이는 병행이 가능하므로 최대한 같이 돌아가면 자원을 효율적으로 쓰게 된다.
<br /></p>

<p>위 3가지는 모든 시스템에 공통적으로 적용되는 목표이다.</p>

<p><br /><br /></p>

<p><strong>Batch System에서의 목표</strong></p>

<ul>
  <li>
    <p>Throughput: Batch System은 사용자와의 상호작용이 없는(천공 카드 방식) 방식이다 보니 정해진 단위 시간에 최대한 많은 작업을 처리하도록 한다.
(maximum is the best)
<br /></p>
  </li>
  <li>
    <p>Turnaround Time: 작업전체시간, 어떤 작업이 시스템에 들어온 시각부터 시작돼서 종료되어 나가기까지 걸리는 총 시간이 짧도록 하는 것(프로세스 대기 시간도 여기 포함된다.)</p>
  </li>
  <li>
    <p>CPU 활용: 컴퓨팅 자원을 최대한 비지 않게 사용(Batch system 사용 당시에는 컴퓨팅 자원이 매우 비쌌다.)</p>
  </li>
</ul>

<p><br /><br />&lt;</p>

<p><strong>Interactive systems에서의 목표</strong><br /></p>

<ul>
  <li>
    <p>Responsive time: 사용자의 요구에 빨리 반응하는 시간, 어떤 요청이 시스템에 전달되고 처음으로 시스템이 반응하기까지 걸리는 시간이라고 생각하자.</p>
  </li>
  <li>
    <p>Proportionality: 비례라는 뜻이지만 여기서는 사용자의 기대(예상)에 최대한 유사하게 대응하는 것을 뜻한다.</p>
  </li>
</ul>

<p><br /></p>

<p>여기까지가 우리가 통상적으로 말하는 스케줄링 알고리즘의 목표라고 할 수 있다.</p>

<p><br /></p>

<p><strong>Real time system에서의 목표</strong><br /></p>

<ul>
  <li>
    <p>Deadline: 시간을 엄수해야 하는 특징이 있다.
<br /></p>
  </li>
  <li>
    <p>Predictability: 예측성, Real-time의 예시로 최근 사람들이 애용하는 넷플릭스를 들 수 있는데, 만약 네트워크가 좋지 못해 동영상이 자주 끊기면 사용자는 불만을 느낄 것이다. 이를 막기 위해 네트워크의 상태를 모니터링해 미리 데이터를 버퍼링해 놓는 것도 일종의 예측성이라 할 수 있다.</p>

    <p><br />
<br />
<strong>- Polling</strong><br />
컨트롤러는 상태 레지스터의 비지 비트를 통해 자신의 상태를 나타냄(바쁠때 1, 다음 명령 대기 = 0), 호스트는 명령 레지스터의 명령 준비 완료 비트(command-read bit)를 통해 입출력을 원한다는 신호를 함.<br /><br />
호스트는 다음과 같은 방법으로 핸드셰이킹을 통해 컨트롤러와 협력하며 포트를 통해 출력한다.
<br /><br />
–&gt; CPU가 상태 레지스터의 비지 비트가 0이 될때까지 검사<br />
–&gt; CPU는 명령 레지스터의 write bit를 설정하고 data-out(출력) register에 보낼 데이터를 써줌<br />
–&gt; CPU는 control register안의 command-ready bit을 설정<br />
–&gt; 장치 컨트롤러가 command-ready bit의 설정을 발견하고 자신의 비지 비트 설정<br />
–&gt; 장치 컨트롤러는 명령 레지스터를 읽고 쓰기 명령임을 판단, 출력 레지스터를 읽어 장치로 출력한다.<br />
–&gt; 장치 컨트롤러는 command-ready bit를 0으로 하고 입출력이 성공했음을 알리기 위해 상태 레지스터의 오류 비트를 0으로 바꾸고, 입출력도 완료하였으니 비지 비트도 0으로 바꾼다.<br /></p>
  </li>
</ul>

<p>여기서 CPU는 첫번째 과정에서 비지 비트가 소거될 때까지 루프를 돌며 검사를 반복한다(이 과정이 <strong>polling</strong>이다). 그리고 이 시간이 길어지면 매우 비효율적일 것이며 몇몇 장치들은 호스트가 빨리 서비스해주지 않으면 데이터는 계속 들어오는데 막상 CPU는 하드웨어가 동작이 끝날 때까지 상태를 체크하니 다른 처리가 계속 미뤄지고 오버플로우를 일으키게 될 것이다.
<br /><br />
이런 비효율적인 상황을 보완하기 위해 생겨난 것이 바로 <strong>Interrupt</strong>이다. 이는 입출력 장치가 CPU에 자신의 상태 변화를 통보하는 하드웨어 기법이다.(반복적인 폴링보다 하드웨어 컨트롤러가 자신의 상태가 바뀔 때 CPU에 통보하는 것이 더 효율적)
<br /><br /></p>

<h2 id="interrupt">Interrupt</h2>

<hr />

<p>인터럽트(Interrupt)란 CPU가 처리 중에 있을 때, 입출력 하드웨어 장치나 다른 예외적 상황의 발생으로 처리가 필요한 상황에 CPU를 불러 처리하도록 하는 것이다.<br />
‘장치 컨트롤러가 인터럽트를 걸면 CPU는 이를 캐치’
<br /></p>

<p>즉 치킨을 주문해놓고 문 앞에서 목빠지게 기다렸던 것이 polling 방식이라면, 치킨이 튀겨지는 동안 은행 등의 다른 볼일을 보다가 치킨 집에서 연락이 오면(인터럽트) 맞춰서 찾아가는 효율적인 방식이라고 생각하면 편할 것 같다.
<br /><br /></p>

<p>CPU는 <strong>IRQ(Interrupt ReQuest) Line</strong>을 가지고 있는데, 하나의 명령어의 실행을 완료할 때마다 항상 이 선을 검사한다. 컨트롤러가 이 라인에 신호를 보내면 CPU는 하던 일을 잠깐 멈추고(경우에 따라 인터럽트를 지연시키기도 한다.) 현재 작업 내용을 Context에 잠깐 저장한 상태로 Interrupt handling을 하게 된다. 처리가 끝나면 context를 다시 불러와 작업을 재개한다.
<br />
<strong>Interrupt handling</strong> <br /></p>

<ul>
  <li>시스템 스택에 context를 저장해놓고 일이 끝나면 pop시켜 다시 작업을 한다. <br />
Polling: 비효율적 <br />
<strong>Vectored interrupt system:</strong> 가장 많이 쓰이는 방식으로 IRQ에 벡터 값을 넣어서 분기한다.</li>
</ul>

<p><br />
<br /></p>

<h2 id="dmadirect-memory-access">DMA(Direct Memory Access)</h2>

<hr />

<p>고속 장치에서 들어오는 인터럽트는 CPU에게 부담을 준다. 그래서 부담을 덜어주기 위한 대행자를 만들었는데 그것이 DMA 컨트롤러이다. <br />
<br />
역할: 컨트롤러가 장치와 메모리 사이에서 CPU가 개입하지 않고 대행해준다.
<br />
만약 DMA 컨트롤러가 없다면 CPU에게 매 바이트마다 인터럽트가 들어올 것이다.</p>

<p><br /></p>

<hr />

<hr />
:ET